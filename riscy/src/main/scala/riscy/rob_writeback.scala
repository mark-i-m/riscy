package riscy

import Chisel._

// Values that were generated by ALUs, LSQ in the current cycle and need to be
// stored
class RobWbEntry extends Bundle {
  // The data value to be stored
  val data = Bits(INPUT, width=64)
  // Indicates whether the data value is actually a 64-bit address
  val is_addr = Bool(INPUT)
  // The operand identifiers for the data value
  val operand = Bits(INPUT, width=6)
  // Indicates whether the data value is valid
  val valid = Bool(INPUT)
  // Indicates whether the branch was taken. Valid only if the instruction
  // executed by the ALU was a branch. If valid, the `bits` attribute will
  // indicate whether the branch was taken.
  val is_branch_taken = Valid(Bool(INPUT))
  // The computed branch target. Use in conjunction with is_branch_taken ie.
  // only if the valid bit is set.
  val branch_target = UInt(INPUT, 64)
  // The tags for the branch instruction. Use only if valid bit is set for
  // is_branch_taken
  val branch_tag = UInt(INPUT, 6)
  // The PCs of the branch instruction. Use only if valid bit is set for
  // is_branch_taken
  val branch_PC = UInt(INPUT, 64)
}

class RobWbInput(numEntries: Int) extends Bundle {
  val entry = Vec(numEntries, (new RobWbEntry).asInput) 
}

// Represents the values that were stored 2 cycles ago and need to be written
// back to the ROB
class RobWbOutput(numEntries: Int) extends Bundle {
  val entry = Vec(numEntries, (new RobWbEntry).asOutput) 
}

// Results stored for the instructions issued in the previous two cycles which
// can be used for bypass
class RobWbStore(numEntries: Int) extends Bundle {
  // Values stored for instructions issued 1 cycle ago
  val entry_s1 = Vec(numEntries, (new RobWbEntry).asOutput)

  // Values stored for instructions issued 2 cycle ago
  val entry_s2 = Vec(numEntries, (new RobWbEntry).asOutput)
}

// Maintains two cycles worth of results from the ALUs, LSQs which can be used
// for forwarding / bypassing. The output of the ROB writeback is then
// broadcast back to the ROB
class RobWriteback(numEntries : Int) extends Module {
  val io = new Bundle {
    val stall = Bits(INPUT, width=1)
    // Takes in the input data values and valid bits to be stored in the
    // current cycle
    val input = new RobWbInput(numEntries)
    // Stored values for 2 cycles which can be used for bypass
    val store = new RobWbStore(numEntries)
    // Generates the data values and valid bits stored 2 cycles ago. These
    // values are then written back to the ROB
    val output = new RobWbOutput(numEntries)
  }

  // Results from instructions that were issued 1 cycle ago
  val data_s1 = Vec(numEntries, Reg(UInt(width=64)))
  val is_addr_s1 = Vec(numEntries, Reg(init=Bool(false)))
  val operand_s1 = Vec(numEntries, Reg(UInt(width=6)))
  val valid_s1 = Vec(numEntries, Reg(init=Bool(false)))
  val is_branch_taken_valid_s1 = Vec(numEntries, Reg(init=Bool(false)))
  val is_branch_taken_bits_s1 = Vec(numEntries, Reg(init=Bool(false)))
  val branch_target_s1 = Vec(numEntries, Reg(UInt(width=64)))
  val branch_tag_s1 = Vec(numEntries, Reg(UInt(width=6)))
  val branch_PC_s1 = Vec(numEntries, Reg(UInt(width=64)))

  // Results from instructions that were issued 2 cycle ago
  val data_s2 = Vec(numEntries, Reg(UInt(width=64)))
  val is_addr_s2 = Vec(numEntries, Reg(init=Bool(false)))
  val operand_s2 = Vec(numEntries, Reg(UInt(width=6)))
  val valid_s2 = Vec(numEntries, Reg(init=Bool(false)))
  val is_branch_taken_valid_s2 = Vec(numEntries, Reg(init=Bool(false)))
  val is_branch_taken_bits_s2 = Vec(numEntries, Reg(init=Bool(false)))
  val branch_target_s2 = Vec(numEntries, Reg(UInt(width=64)))
  val branch_tag_s2 = Vec(numEntries, Reg(UInt(width=6)))
  val branch_PC_s2 = Vec(numEntries, Reg(UInt(width=64)))

  // Hook up wires so that values will be available for bypass
  for (i <- 0 until numEntries) {
    io.store.entry_s1(i).data                  := data_s1(i)
    io.store.entry_s1(i).is_addr               := is_addr_s1(i)
    io.store.entry_s1(i).operand               := operand_s1(i)
    io.store.entry_s1(i).valid                 := valid_s1(i)
    io.store.entry_s1(i).is_branch_taken.valid := is_branch_taken_valid_s1(i)
    io.store.entry_s1(i).is_branch_taken.bits  := is_branch_taken_bits_s1(i)
    io.store.entry_s1(i).branch_target         := branch_target_s1(i)
    io.store.entry_s1(i).branch_tag            := branch_tag_s1(i)
    io.store.entry_s1(i).branch_PC             := branch_PC_s1(i)

    io.store.entry_s2(i).data                  := data_s2(i)
    io.store.entry_s2(i).is_addr               := is_addr_s2(i)
    io.store.entry_s2(i).operand               := operand_s2(i)
    io.store.entry_s2(i).valid                 := valid_s2(i)
    io.store.entry_s2(i).is_branch_taken.valid := is_branch_taken_valid_s2(i)
    io.store.entry_s2(i).is_branch_taken.bits  := is_branch_taken_bits_s2(i)
    io.store.entry_s2(i).branch_target         := branch_target_s2(i)
    io.store.entry_s2(i).branch_tag            := branch_tag_s2(i)
    io.store.entry_s2(i).branch_PC             := branch_PC_s2(i)
  }

  // Hand over the results from instructions that were issued 2 cycles ago.
  // These values will be written to ROB
  for (i <- 0 until numEntries) {
    io.output.entry(i).data                  := data_s2(i)
    io.output.entry(i).is_addr               := is_addr_s2(i)
    io.output.entry(i).operand               := operand_s2(i)
    io.output.entry(i).valid                 := valid_s2(i)
    io.output.entry(i).is_branch_taken.valid := is_branch_taken_valid_s2(i)
    io.output.entry(i).is_branch_taken.bits  := is_branch_taken_bits_s2(i)
    io.output.entry(i).branch_target         := branch_target_s2(i)
    io.output.entry(i).branch_tag            := branch_tag_s2(i)
    io.output.entry(i).branch_PC             := branch_PC_s2(i)
  }

  when(!io.stall) {
    // Shift data values so that they will be available for ROB writeback in
    // the next cycle
    data_s2                  := data_s1
    is_addr_s2               := is_addr_s1
    operand_s2               := operand_s1
    valid_s2                 := valid_s1
    is_branch_taken_valid_s2 := is_branch_taken_valid_s1
    is_branch_taken_bits_s2  := is_branch_taken_bits_s1
    branch_target_s2         := branch_target_s1
    branch_tag_s2            := branch_tag_s1
    branch_PC_s2             := branch_PC_s1

    // Input values will be stored and available in the next cycle
    for (i <- 0 until numEntries) {
      data_s1(i)                  := io.input.entry(i).data
      is_addr_s1(i)               := io.input.entry(i).is_addr
      operand_s1(i)               := io.input.entry(i).operand
      valid_s1(i)                 := io.input.entry(i).valid
      is_branch_taken_valid_s1(i) := io.input.entry(i).is_branch_taken.valid
      is_branch_taken_bits_s1(i)  := io.input.entry(i).is_branch_taken.bits
      branch_target_s1(i)         := io.input.entry(i).branch_target
      branch_tag_s1(i)            := io.input.entry(i).branch_tag
      branch_PC_s1(i)             := io.input.entry(i).branch_PC
    }
  } .otherwise {
    // Sit pretty because somebody asked us to stall
    // XXX-kbavishi: Is it okay to output the same values as we did in the
    // previous cycle? An alternative approach would be to reset output valid
    // bits.
  }
}

class RobWritebackTests(c: RobWriteback) extends Tester(c) { 
  // Utility functions
  def expect_output_valid(c : RobWriteback, values : List[Boolean]) = {
    for (i <- 0 until 6) {
      expect(c.io.output.entry(i).valid, values(i))
    }
  }
  def expect_output_data(c : RobWriteback, values : List[Int]) = {
    for (i <- 0 until 6) {
      expect(c.io.output.entry(i).data, values(i))
    }
  }
  def expect_output_is_addr(c : RobWriteback, values : List[Boolean]) = {
    for (i <- 0 until 6) {
      expect(c.io.output.entry(i).is_addr, values(i))
    }
  }
  def expect_output_operand(c : RobWriteback, values : List[Int]) = {
    for (i <- 0 until 6) {
      expect(c.io.output.entry(i).operand, values(i))
    }
  }
  def poke_input_valid(c : RobWriteback, values : List[Boolean]) = {
    for (i <- 0 until 6) {
      poke(c.io.input.entry(i).valid, values(i))
    }
  }
  def poke_input_data(c : RobWriteback, values : List[Int]) = {
    for (i <- 0 until 6) {
      poke(c.io.input.entry(i).data, values(i))
    }
  }
  def poke_input_is_addr(c : RobWriteback, values : List[Boolean]) = {
    for (i <- 0 until 6) {
      poke(c.io.input.entry(i).is_addr, values(i))
    }
  }
  def poke_input_operand(c : RobWriteback, values : List[Int]) = {
    for (i <- 0 until 6) {
      poke(c.io.input.entry(i).operand, values(i))
    }
  }

  // For now assume that there will be no stalling
  poke(c.io.stall, false)

  // Cycle 0: Add some input data values to be stored
  poke_input_valid(c, List.fill(6)(true))
  poke_input_data(c, List.range(0, 6))
  poke_input_is_addr(c, List.fill(6)(false))
  poke_input_operand(c, List.range(0, 6))
  // Initially we expect output valid bits to be unset
  expect_output_valid(c, List.fill(6)(false))
  step(1)

  // Cycle 1: No values will still be available
  expect_output_valid(c, List.fill(6)(false))
  // Add some new data values to be stored. Make entry #0 invalid
  poke_input_valid(c, List(false, true, true, true, true, true))
  poke_input_data(c, List.range(6, 12))
  poke_input_is_addr(c, List(false, true, true, true, true, true))
  poke_input_operand(c, List.range(6, 12))
  step(1)

  // Cycle 2: The values stored in the cycle #0 should now be available.
  expect_output_valid(c, List.fill(6)(true))
  expect_output_data(c, List.range(0, 6))
  expect_output_is_addr(c, List.fill(6)(false))
  expect_output_operand(c, List.range(0, 6))
  // Also add some new data values to be stored.
  poke_input_valid(c, List.fill(6)(true))
  poke_input_data(c, List.range(12, 18))
  poke_input_is_addr(c, List.fill(6)(true))
  poke_input_operand(c, List.range(12, 18))
  step(1)

  // Cycle 3: The values stored in cycle #1 should now be available. Entry #0
  // should be marked invalid
  expect_output_valid(c, List(false, true, true, true, true, true))
  expect_output_data(c, List.range(6, 12))
  expect_output_is_addr(c, List(false, true, true, true, true, true))
  expect_output_operand(c, List.range(6, 12))
  // Also add some new data values to be stored.
  poke_input_valid(c, List.fill(6)(true))
  poke_input_data(c, List.range(18, 24))
  poke_input_is_addr(c, List.fill(6)(true))
  poke_input_operand(c, List.range(18, 24))
  // Stall the ROB writeback. Verify that new values are not reported
  poke(c.io.stall, true)
  step(1)

  // Cycle 4: Should return the same values as in the previous cycle
  expect_output_valid(c, List(false, true, true, true, true, true))
  expect_output_data(c, List.range(6, 12))
  expect_output_is_addr(c, List(false, true, true, true, true, true))
  expect_output_operand(c, List.range(6, 12))
}

class RobWritebackGenerator extends TestGenerator {
  def genMod(): Module = Module(new RobWriteback(6))
  def genTest[T <: Module](c: T): Tester[T] = 
    (new RobWritebackTests(c.asInstanceOf[RobWriteback])).asInstanceOf[Tester[T]]
}
