package riscy

import Chisel._
import scala.language.reflectiveCalls

class LSQEntry extends AddBufEntry {
  // TODO
  val addr = Valid(UInt(OUTPUT, 32))
  val value = Valid(UInt(OUTPUT, 64))
  val ready  = Bool(OUTPUT) // Entry populated or not
}

class LSQ extends Module {
  val io = new Bundle {
    // TODO
    val stCommit = Vec(4, Bool(INPUT))
    val robWb = new RobWbStore(6).flip
    val resEntry = Vec.fill(4) { Valid(new AddBufEntry).flip }
    //val fillEntry = Valid(new LSQEntry)
    //val issuedEntry = Valid(new LSQEntry).asOutput
    val stAddr = Valid(UInt(OUTPUT, 32))
    val stValue = UInt(OUTPUT, 64)
    val currentLen = UInt(OUTPUT, 4)
  }

  // Number of entries in the Queue
  val DEPTH = 16

  //val addrqW = Vec.fill(4) { Valid(new LSQEntry) }
  val addrqW = Vec.fill(DEPTH) { Valid(new LSQEntry) }
  val addrq = Vec.tabulate(DEPTH) { i => RegEnable(addrqW(i).bits, addrqW(i).valid) }

  val WbCamAddr = Module(new CAM(6, DEPTH, 64))
  val WbCamValue = Module(new CAM(6, DEPTH, 6))

  for ( i <- 0 until DEPTH) {
    WbCamAddr.io.input_bits(i) := addrq(i).robLoc
    WbCamValue.io.input_bits(i) := addrq(i).robLoc
  }

  // Addresses should be generated by ALUs and hence in the first 4 entries only
  for ( i <- 0 until 4) {
    //TODO
    //when(io.robWb.isAddr === Bool(true)) {
      WbCamAddr.io.compare_bits(i) := io.robWb.data_s1(i)
    //} .otherwise {
      WbCamValue.io.compare_bits(i) := io.robWb.data_s1(i)
    //}
  }
  //val counter = new CounterUpDown(DEPTH)

  val resVector: UInt = Cat(io.resEntry(3).valid, io.resEntry(2).valid, io.resEntry(1).valid, io.resEntry(0).valid)
  // Number of entries being reserved in the queue
  val resNum = PopCount(resVector)

  // Length of the queue
  val queueLength = UInt()

  // Register holding pointer to top of the queue
  val qTop = Reg(init = UInt(0), next = queueLength + resNum)
  queueLength := qTop
  
  // Wires that will feed inputs to the queue
  val res = Vec.fill(4) { Valid(new AddBufEntry).flip }

  // Logic to determine routing of inputs
  when (resVector === UInt(15)) {
    res(0) := io.resEntry(0)
    res(1) := io.resEntry(1)
    res(2) := io.resEntry(2)
    res(3) := io.resEntry(3)
  } .elsewhen (resVector === UInt(14)) {
    res(0) := io.resEntry(1)
    res(1) := io.resEntry(2)
    res(2) := io.resEntry(3)
    res(3).valid := Bool(false)
  } .elsewhen (resVector === UInt(13)) {
    res(0) := io.resEntry(0)
    res(1) := io.resEntry(2)
    res(2) := io.resEntry(3)
    res(3).valid := Bool(false)
  } .elsewhen (resVector === UInt(12)) {
    res(0) := io.resEntry(2)
    res(1) := io.resEntry(3)
    res(2).valid := Bool(false)
    res(3).valid := Bool(false)
  } .elsewhen (resVector === UInt(11)) {
    res(0) := io.resEntry(0)
    res(1) := io.resEntry(1)
    res(2) := io.resEntry(3)
    res(3).valid := Bool(false)
  } .elsewhen (resVector === UInt(10)) {
    res(0) := io.resEntry(1)
    res(1) := io.resEntry(3)
    res(2).valid := Bool(false)
    res(3).valid := Bool(false)
  } .elsewhen (resVector === UInt(9)) {
    res(0) := io.resEntry(0)
    res(1) := io.resEntry(3)
    res(2).valid := Bool(false)
    res(3).valid := Bool(false)
  } .elsewhen (resVector === UInt(8)) {
    res(0) := io.resEntry(3)
    res(1).valid := Bool(false)
    res(2).valid := Bool(false)
    res(3).valid := Bool(false)
  } .elsewhen (resVector === UInt(7)) {
    res(0) := io.resEntry(0)
    res(1) := io.resEntry(1)
    res(2) := io.resEntry(2)
    res(3).valid := Bool(false)
  } .elsewhen (resVector === UInt(6)) {
    res(0) := io.resEntry(1)
    res(1) := io.resEntry(2)
    res(2).valid := Bool(false)
    res(3).valid := Bool(false)
  } .elsewhen (resVector === UInt(5)) {
    res(0) := io.resEntry(0)
    res(1) := io.resEntry(2)
    res(2).valid := Bool(false)
    res(3).valid := Bool(false)
  } .elsewhen (resVector === UInt(4)) {
    res(0) := io.resEntry(2)
    res(1).valid := Bool(false)
    res(2).valid := Bool(false)
    res(3).valid := Bool(false)
  } .elsewhen (resVector === UInt(3)) {
    res(0) := io.resEntry(0)
    res(1) := io.resEntry(1)
    res(2).valid := Bool(false)
    res(3).valid := Bool(false)
  } .elsewhen (resVector === UInt(2)) {
    res(0) := io.resEntry(1)
    res(1).valid := Bool(false)
    res(2).valid := Bool(false)
    res(3).valid := Bool(false)
  } .elsewhen (resVector === UInt(1)) {
    res(0) := io.resEntry(0)
    res(1).valid := Bool(false)
    res(2).valid := Bool(false)
    res(3).valid := Bool(false)
  } .otherwise {
    res(0).valid := Bool(false)
    res(1).valid := Bool(false)
    res(2).valid := Bool(false)
    res(3).valid := Bool(false)
  }

  val inputs = Vec.fill(4) { (new AddBufEntry).flip }

  for ( i <- 0 until 4) {
    inputs(i) := res(i).bits
  }

  // Hook up inputs to entries in the queue
  for (i <- 0 until 4) {
    addrq(queueLength + UInt(i)) := res(i)
  }

  // Feedback to the arbiter on the number of entries filled in the queue
  io.currentLen := queueLength

  for ( i <- 0 until DEPTH) {
    for ( j <- 0 until 4) {
      // TODO - Check if it's an address
      when (WbCamAddr.io.hit(j)(i) && io.robWb.valid_s1(j)) {
        addrq(i).addr.valid := Bool(true)
        addrq(i).addr.bits := io.robWb.data_s1(j)
      }
    }
    for ( j <- 0 until 6) {
      when (WbCamValue.io.hit(j)(i) && io.robWb.valid_s1(j) && addrq(i).st_nld) {
        addrq(i).value.valid := Bool(true)
        addrq(i).value.bits := io.robWb.data_s1(j)
      }
    }
  }

  // An entry is ready to leave the queue when both its value and address are
  // available
  for ( i <- 0 until DEPTH) {
    when (addrq(i).addr.valid && addrq(i).value.valid) {
      addrq(i).ready := Bool(true)
    } .otherwise {
      addrq(i).ready := Bool(false)
    }
  }

  //val depRow = Vec.tabulate(DEPTH) { i => UInt(i) -> Reg(UInt(width=1)) }
  val depRow = Vec.fill(DEPTH) { Reg(UInt(width=1)) }
  val depMatrix = Vec.tabulate(DEPTH) { i => depRow }

  for (i <- 0 until DEPTH) {
    depMatrix(i)(i) := UInt(0)
  }

  /*
  val tagMatch = Vec.fill(DEPTH) { Bool() }
  val addrMatch = Vec.fill(DEPTH) { Bool() }
  for (i <- 0 until DEPTH) {
    tagMatch(i) := (io.robLoc === addrq(i).robLoc)
    when (tagMatch(i)) {
      addrq(i).addr.bits := io.addr
    }
  }
  */

  // The dependency matrix
  /*
  for (i <- 0 until DEPTH) {
    for (j <- 0 until DEPTH) {
      addrMatch(j) := (io.addr === addrq(j).addr.bits)
        when (addrMatch(j)) {
          //addrq(i).value := io.value
          depMatrix(i)._2(i)._2 := UInt(1)
        }
    }
  }
  */

  for ( i <- 0 until 4) {
    when ( res(i).valid && !inputs(i).st_nld) {
      for ( j <- 0 until DEPTH) {
        depMatrix(queueLength + UInt(i))(j) := UInt(1)
      }
    }
  }
  

  io.stAddr.bits := addrq(0).addr.bits
  io.stValue := addrq(0).value.bits
  when (io.stCommit(0)) { // TODO: this should be done for all stCommit signals, not just 0
    io.stAddr.valid := Bool(true)
    for ( i <- 0 until DEPTH) {
      depMatrix(0)(i) := UInt(0)
    }
  } .otherwise {
    io.stAddr.valid := Bool(false)
  }

}

class LSQTests(c: LSQ) extends Tester(c) {
  println("TODO")
}

class LSQGenerator extends TestGenerator {
  def genMod(): Module = Module(new LSQ())
  def genTest[T <: Module](c: T): Tester[T] =
    (new LSQTests(c.asInstanceOf[LSQ])).asInstanceOf[Tester[T]]
}
